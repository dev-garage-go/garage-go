// Postman Docs: https://documenter.getpostman.com/view/15366798/2sAXjKasp4#intro -> CheckoutPro
import { NextResponse } from 'next/server';

import { InitialOrderServerResponse, InitialOrderServerResponseType } from '@/backend/database/schemas';
import { HttpStatus, APIResponse, EndpointResponse } from '@/backend/types';
import { getBookingByID } from '@/backend/actions';
import { firstLetterUppercase } from '@/utils/formatters';

import { ServiceNamesMap } from "@/features/services";
import { PreferenceMPValidator } from '@/features/payment';


if (!process.env.MERCADO_PAGO_ACCESS_TOKEN) {
  throw new Error('the enviroment variable MERCADO_PAGO_ACCESS_TOKEN not found')
}

if (!process.env.NEXT_PUBLIC_BASE_URL) {
  throw new Error('the enviroment variable NEXT_PUBLIC_BASE_URL not found')
}

const isProd = process.env.NODE_ENV === 'production'
const token = process.env.MERCADO_PAGO_ACCESS_TOKEN
const domain = isProd ? process.env.NEXT_PUBLIC_BASE_URL : 'https://bd1a8bc16aa5.ngrok-free.app' // url generated by ngrok

export async function POST(request: Request): Promise<NextResponse<APIResponse<EndpointResponse | null>>> {
  try {
    const body: unknown = await request.json()
    const order: InitialOrderServerResponseType = InitialOrderServerResponse.parse(body)

    const responseBooking = await getBookingByID(order.booking_id)
    if (!responseBooking.success || !responseBooking.data) throw new Error(responseBooking.error)
    const booking = responseBooking.data
    const serviceName = firstLetterUppercase(ServiceNamesMap[booking.service.name])

    const preference = {
      auto_return: 'approved',                                              // Retorna sin importar si el pago fue exitoso o no
      statement_descriptor: 'Garage Go',                                    // Descripción en MP
      external_reference: order._id,                                       // ID de la orden creada en la base de datos de la app 
      notification_url: `${domain}/api/payment/mercado-pago/webhook`,       // URL del Webhook para que MP mande la info de la transacción
      back_urls: {
        success: `${domain}/services`,
        failure: `${domain}/services`,
        pending: `${domain}/services`
      },
      items: [{
        id: booking.service.type,                                                      // type of service or ID of service (payload.serviceType)
        title: `Garage Go - ${serviceName}`,
        category_id: "Servicios",
        currency_id: 'ARS',
        description: `${serviceName} | Servicios Garage Go`,
        quantity: 1,
        unit_price: order.total_price
      }],
      payer: {
        name: booking.user.name,
        surname: booking.user.lastName,
        email: booking.user.email,
        phone: {
          area_code: '+56',
          number: booking.user.phone,
        }
      },
      payment_methods: {
        installments: 6,
        excluded_payment_types: [
          { id: 'atm' },              // Cajeros automáticos
          { id: 'ticket' },           // Vales o cupones para pagar en tiendas físicas
          { id: 'bank_transfer' }     // Transferencias offline (no instantáneas)
        ],
        excluded_payment_methods: [
          { id: 'servipag' },
          { id: 'sencillito' }
        ],
      }
    }

    const myHeaders = new Headers()
    myHeaders.append('Content-Type', 'application/json')
    myHeaders.append('Authorization', `Bearer ${token}`)

    const response = await fetch('https://api.mercadopago.com/checkout/preferences', {
      method: 'POST',
      headers: myHeaders,
      body: JSON.stringify(preference),
      redirect: 'follow'
    })

    if (!response.ok) {
      const err = await response.json()
      return NextResponse.json<APIResponse<null>>({
        success: false,
        error: `mercado pago error ${err}`
      }, { status: response.status })
    }

    const mpBody = await response.json()
    const check = PreferenceMPValidator.safeParse(mpBody)

    if (!check.success) {
      console.error('zod error validating MP preference', check.error)
      return NextResponse.json<APIResponse<null>>({
        success: false,
        error: check.error.message
      }, { status: response.status })
    }

    const data = check.data

    return NextResponse.json<APIResponse<EndpointResponse>>({
      success: true,
      data: { redirectURL: data.init_point }
    }, { status: HttpStatus.OK, }
    )
  }

  catch (error) {
    console.error(error)
    return NextResponse.json<APIResponse<null>>({
      success: false,
      error: error as string
    }, { status: HttpStatus.INTERNAL_SERVER_ERROR })
  }
}