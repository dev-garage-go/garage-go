// Postman Docs: https://documenter.getpostman.com/view/15366798/2sAXjKasp4#intro -> CheckoutPro
import { NextResponse } from 'next/server';
import { HttpStatus } from '@/backend/types';
import { PreferenceMPValidator } from '@/features/payment';
import { insertOrder } from '@/backend/database/queries';
import { InitialOrderType } from '@/features/orders';


if (!process.env.MERCADO_PAGO_ACCESS_TOKEN) {
  throw new Error('the enviroment variable MERCADO_PAGO_ACCESS_TOKEN not found')
}

if (!process.env.NEXT_PUBLIC_BASE_URL) {
  throw new Error('the enviroment variable NEXT_PUBLIC_BASE_URL not found')
}

const isProd = process.env.NODE_ENV === 'production'
const token = process.env.MERCADO_PAGO_ACCESS_TOKEN
const domain = isProd ? process.env.NEXT_PUBLIC_BASE_URL : 'https://9aea-181-118-99-121.ngrok-free.app' // url generated by ngrok

export async function POST(request: Request) {
  try {
    const payload = await request.json()

    const initialOrder: InitialOrderType = {
      provider: 'mercado_pago',
      email: 'arraga.alex@gmail.com',     // payload.email
      booking_id: 'uuid-booking',         // payload.booking.id
      pay_status: 'pending',
      total_price: 100,                   // payload.total_price
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      expires_at: new Date(Date.now() + 1000 * 60 * 60).toISOString() // TTL = 1h
    }

    const result = await insertOrder(initialOrder)
    if (!result.success || !result.data) throw new Error(result.error)
    const order = result.data

    const preference = {
      auto_return: 'approved',                                              // Retorna sin importar si el pago fue exitoso o no
      statement_descriptor: 'Garage Go',                                    // Descripción en MP
      external_reference: order._id,                                       // ID de la orden creada en la base de datos de la app 
      notification_url: `${domain}/api/payment/mercado-pago/webhook`,       // URL del Webhook para que MP mande la info de la transacción
      back_urls: {
        success: `${domain}/services`,
        failure: `${domain}/services`,
        pending: `${domain}/services`
      },
      items: [{
        id: 'mileage',                                                      // type of service or ID of service (payload.serviceType)
        title: "Servicios GarageGo",
        category_id: "Servicios",
        currency_id: 'ARS',
        description: "Mantención por kilometraje | Garage Go",
        quantity: 1,
        unit_price: 100
      }],
      payer: {
        name: 'Lisandro',
        surname: 'Martinez',
        email: 'lisandromartinez@gmail.com',
        phone: {
          area_code: '+56',
          number: '123456789',
        }
      },
      payment_methods: {
        installments: 6,
        excluded_payment_types: [
          { id: 'atm' },              // Cajeros automáticos
          { id: 'ticket' },           // Vales o cupones para pagar en tiendas físicas
          { id: 'bank_transfer' }     // Transferencias offline (no instantáneas)
        ],
        excluded_payment_methods: [
          { id: 'servipag' },
          { id: 'sencillito' }
        ],
      }
    }

    const myHeaders = new Headers()
    myHeaders.append('Content-Type', 'application/json')
    myHeaders.append('Authorization', `Bearer ${token}`)

    const response = await fetch('https://api.mercadopago.com/checkout/preferences', {
      method: 'POST',
      headers: myHeaders,
      body: JSON.stringify(preference),
      redirect: 'follow'
    })

    if (!response.ok) {
      const err = await response.json()
      return NextResponse.json({ message: 'mercado pago error', err }, { status: response.status })
    }

    const body = await response.json()
    const check = PreferenceMPValidator.safeParse(body)

    if (!check.success) {
      console.error('zod error validating MP preference', check.error)
      return NextResponse.json({ error: check.error }, { status: response.status })
    }

    const data = check.data

    return NextResponse.json(
      { redirectURL: data.init_point },
      { status: HttpStatus.OK, }
    )
  }

  catch (error) {
    console.error(error)
    return NextResponse.json({ error: error }, { status: HttpStatus.INTERNAL_SERVER_ERROR })
  }
}